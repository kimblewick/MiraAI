name: Deploy to AWS

on:
  push:
    branches:
      - dev
      - main
    paths:  
      - 'app/backend/**'
      - 'app/frontend/**'
      - 'infra/**'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      deploy_lambda:
        description: 'Deploy Lambda'
        required: false
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy Frontend'
        required: false
        default: true
        type: boolean
      deploy_terraform:
        description: 'Apply Terraform'
        required: false
        default: true
        type: boolean

jobs:
  # Job 1: Detect changed components
  detect-changes:
    name: Detect Changed Components
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      infra: ${{ steps.filter.outputs.infra }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Detect file changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          base: ${{ github.event.before }}  
          filters: |
            backend:
              - 'app/backend/**'
            frontend:
              - 'app/frontend/**'
            infra:
              - 'infra/**'
      
      - name: Show detected changes
        run: |
          echo "================================================"
          echo "üîç File Change Detection"
          echo "================================================"
          echo ""
          echo "Detected changes:"
          echo "  Backend: ${{ steps.filter.outputs.backend }}"
          echo "  Frontend: ${{ steps.filter.outputs.frontend }}"
          echo "  Infrastructure: ${{ steps.filter.outputs.infra }}"
          echo ""

  # Job 2: deploy Lambda to AWS
  deploy-lambda:
    name: Deploy Lambda to AWS
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.backend == 'true' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_lambda == 'true')
    runs-on: ubuntu-latest
    
    steps:
      # 1. Checkout Code
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Setup Python
      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      # 3. Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 4. Determine Environment
      - name: Determine deployment environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="dev"  
          else
            ENV="dev"
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to environment: ${ENV}"
          
          # Set Lambda function name based on environment
          echo "lambda_function_name=mira-api-${ENV}" >> $GITHUB_OUTPUT
          echo "Lambda function: mira-api-${ENV}"

      # 5. Clean Previous Build
      - name: Clean previous build artifacts
        run: |
          cd app/backend
          rm -rf dist lambda-api.zip
          echo "‚úÖ Cleaned build artifacts"

      # 6. Create Distribution Directory
      - name: Create distribution directory
        run: |
          cd app/backend
          mkdir -p dist
          echo "‚úÖ Distribution directory created"

      # 7. Copy Application Code
      - name: Copy application code
        run: |
          cd app/backend
          cp handler.py dist/
          cp -r api common dist/
          echo "‚úÖ Application code copied"

      # 8. Install Dependencies
      - name: Install Python dependencies
        run: |
          cd app/backend
          
          echo "Installing dependencies for Lambda runtime..."
          pip install -r requirements.txt \
            -t dist/ \
            --platform manylinux2014_x86_64 \
            --python-version 3.10 \
            --implementation cp \
            --only-binary=:all: \
            --upgrade \
            --quiet
          
          echo "‚úÖ Dependencies installed"

      # 9. Create Deployment Package
      - name: Create deployment package
        run: |
          cd app/backend/dist
          zip -r ../lambda-api.zip . -q
          cd ..
          
          ZIP_SIZE=$(du -h lambda-api.zip | cut -f1)
          echo "‚úÖ Deployment package created (${ZIP_SIZE})"
          
          # Check size
          SIZE_MB=$(du -m lambda-api.zip | cut -f1)
          if [ $SIZE_MB -gt 50 ]; then
            echo "‚ö†Ô∏è  WARNING: Zip file is ${SIZE_MB}MB (AWS limit is 50MB for direct upload)"
            echo "Consider using S3 for deployment if this continues to grow"
          fi

      # 10. Upload to Lambda
      - name: Deploy to Lambda
        run: |
          cd app/backend
          
          echo "Uploading to Lambda function: ${{ steps.env.outputs.lambda_function_name }}"
          
          aws lambda update-function-code \
            --function-name ${{ steps.env.outputs.lambda_function_name }} \
            --zip-file fileb://lambda-api.zip \
            --region ${{ secrets.AWS_REGION }} \
            --no-cli-pager
          
          echo "‚úÖ Code uploaded successfully"

      # 11. Wait for Lambda Update
      - name: Wait for Lambda to be ready
        run: |
          echo "Waiting for Lambda function to be ready..."
          
          aws lambda wait function-updated \
            --function-name ${{ steps.env.outputs.lambda_function_name }} \
            --region ${{ secrets.AWS_REGION }}
          
          echo "‚úÖ Lambda function is ready"

      # 12. Test Deployment
      - name: Test health endpoint
        run: |
          echo "Testing health endpoint..."
          
          API_URL="https://jwlaxtz15k.execute-api.us-east-1.amazonaws.com"
          
          # Wait a bit for Lambda to fully initialize
          sleep 5
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/health")
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ Health check passed (HTTP ${HTTP_CODE})"
            
            RESPONSE=$(curl -s "${API_URL}/health")
            echo "Response: $RESPONSE"
          else
            echo "‚ùå Health check failed (HTTP ${HTTP_CODE})"
            echo ""
            echo "Check Lambda logs:"
            echo "  aws logs tail /aws/lambda/${{ steps.env.outputs.lambda_function_name }} --region ${{ secrets.AWS_REGION }} --since 2m"
            exit 1
          fi

      # 13. Show Lambda Deployment Info
      - name: Show Lambda deployment information
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ Lambda Deployment Successful!"
          echo "================================================"
          echo ""
          echo "Lambda Function: ${{ steps.env.outputs.lambda_function_name }}"
          echo "Environment: ${{ steps.env.outputs.environment }}"
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo ""
          echo "API Endpoints:"
          echo "  Health: https://jwlaxtz15k.execute-api.us-east-1.amazonaws.com/health"
          echo "  Profile: https://jwlaxtz15k.execute-api.us-east-1.amazonaws.com/profile"
          echo "  Chat: https://jwlaxtz15k.execute-api.us-east-1.amazonaws.com/chat"
          echo ""
          echo "Deployed by: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          echo ""
          
          # Show Lambda info
          aws lambda get-function \
            --function-name ${{ steps.env.outputs.lambda_function_name }} \
            --region ${{ secrets.AWS_REGION }} \
            --query '{Runtime:Configuration.Runtime,MemorySize:Configuration.MemorySize,Timeout:Configuration.Timeout,LastModified:Configuration.LastModified}' \
            --output table

  # Job 3: deploy frontend to S3
  deploy-frontend:
    name: Deploy Frontend to S3
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.frontend == 'true' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_frontend == 'true')
    runs-on: ubuntu-latest
    
    steps:
      # 1. Checkout
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Setup Node
      - name: Setup Node.js 18
        uses: actions/setup-node@v3
        with:
          node-version: "18"
          cache: 'npm'
          cache-dependency-path: app/frontend/package-lock.json

      # 3. Configure AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 4. Determine Environment
      - name: Determine deployment environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="dev"
          else
            ENV="dev"
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to environment: ${ENV}"
          
          # Set S3 bucket name based on environment
          if [[ "${ENV}" == "prod" ]]; then
            echo "s3_bucket=mira-prod-frontend-us-east-1" >> $GITHUB_OUTPUT
          else
            echo "s3_bucket=mira-dev-frontend-us-east-1" >> $GITHUB_OUTPUT
          fi

      # 4.1. Get CloudFront Distribution ID
      - name: Get CloudFront Distribution ID
        id: cloudfront
        run: |
          S3_BUCKET="${{ steps.env.outputs.s3_bucket }}"
          
          echo "Looking for CloudFront distribution with S3 origin: ${S3_BUCKET}"
          
          # Get all CloudFront distributions and find the one with our S3 bucket as origin
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[?contains(DomainName, '${S3_BUCKET}')]].Id | [0]" \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          if [[ -z "$DISTRIBUTION_ID" ]] || [[ "$DISTRIBUTION_ID" == "None" ]]; then
            echo "‚ö†Ô∏è No CloudFront distribution found for bucket: ${S3_BUCKET}"
            echo "distribution_id=" >> $GITHUB_OUTPUT
            echo "cloudfront_url=" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found CloudFront distribution: ${DISTRIBUTION_ID}"
            echo "distribution_id=${DISTRIBUTION_ID}" >> $GITHUB_OUTPUT
            
            # Get the CloudFront domain name
            DOMAIN_NAME=$(aws cloudfront get-distribution \
              --id "${DISTRIBUTION_ID}" \
              --query "Distribution.DomainName" \
              --output text \
              --region ${{ secrets.AWS_REGION }})
            
            echo "cloudfront_url=https://${DOMAIN_NAME}" >> $GITHUB_OUTPUT
            echo "CloudFront URL: https://${DOMAIN_NAME}"
          fi

      # 5. Get Cognito Configuration
      - name: Get Cognito configuration from AWS
        id: cognito
        run: |
          echo "Fetching Cognito configuration from AWS..."
          
          # Get the Cognito User Pool ID (mira-user-pool-dev)
          USER_POOL_ID=$(aws cognito-idp list-user-pools \
            --max-results 60 \
            --query "UserPools[?Name=='mira-user-pool-dev'].Id | [0]" \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          if [[ -z "$USER_POOL_ID" ]] || [[ "$USER_POOL_ID" == "None" ]]; then
            echo "‚ùå Could not find Cognito User Pool 'mira-user-pool-dev'"
            exit 1
          fi
          
          echo "‚úÖ Found User Pool ID: ${USER_POOL_ID}"
          echo "user_pool_id=${USER_POOL_ID}" >> $GITHUB_OUTPUT
          
          # Get the App Client ID
          CLIENT_ID=$(aws cognito-idp list-user-pool-clients \
            --user-pool-id "${USER_POOL_ID}" \
            --query "UserPoolClients[?ClientName=='mira-web-client-dev'].ClientId | [0]" \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          if [[ -z "$CLIENT_ID" ]] || [[ "$CLIENT_ID" == "None" ]]; then
            echo "‚ùå Could not find Cognito App Client 'mira-web-client-dev'"
            exit 1
          fi
          
          echo "‚úÖ Found Client ID: ${CLIENT_ID}"
          echo "client_id=${CLIENT_ID}" >> $GITHUB_OUTPUT
          
          # Set Cognito domain
          COGNITO_DOMAIN="cs6620-team-chengdu-dev.auth.${{ secrets.AWS_REGION }}.amazoncognito.com"
          echo "cognito_domain=${COGNITO_DOMAIN}" >> $GITHUB_OUTPUT
          echo "‚úÖ Cognito Domain: ${COGNITO_DOMAIN}"

      # 6. Install Dependencies
      - name: Install dependencies
        run: |
          cd app/frontend
          npm ci
          echo "‚úÖ Dependencies installed"

      # 7. Build Frontend with Environment Variables
      - name: Build frontend
        env:
          VITE_AWS_REGION: ${{ secrets.AWS_REGION }}
          VITE_AWS_COGNITO_USER_POOL_ID: ${{ steps.cognito.outputs.user_pool_id }}
          VITE_AWS_COGNITO_CLIENT_ID: ${{ steps.cognito.outputs.client_id }}
          VITE_AWS_COGNITO_DOMAIN: ${{ steps.cognito.outputs.cognito_domain }}
          VITE_API_BASE_URL: https://jwlaxtz15k.execute-api.us-east-1.amazonaws.com
          VITE_APP_ENV: production
          VITE_COGNITO_CALLBACK_URL: ${{ steps.cloudfront.outputs.cloudfront_url }}/callback
          VITE_COGNITO_LOGOUT_URL: ${{ steps.cloudfront.outputs.cloudfront_url }}/
        run: |
          cd app/frontend
          
          echo "================================================"
          echo "üîß Build Environment Configuration"
          echo "================================================"
          echo "  AWS Region: ${VITE_AWS_REGION}"
          echo "  Cognito User Pool: ${VITE_AWS_COGNITO_USER_POOL_ID}"
          echo "  Cognito Client ID: ${VITE_AWS_COGNITO_CLIENT_ID}"
          echo "  Cognito Domain: ${VITE_AWS_COGNITO_DOMAIN}"
          echo "  API Base URL: ${VITE_API_BASE_URL}"
          echo "  App Environment: ${VITE_APP_ENV}"
          echo "  Callback URL: ${VITE_COGNITO_CALLBACK_URL}"
          echo "  Logout URL: ${VITE_COGNITO_LOGOUT_URL}"
          echo "================================================"
          
          npm run build
          
          # Check build output
          if [ ! -d "dist" ]; then
            echo "‚ùå Build failed - dist directory not created"
            exit 1
          fi
          
          BUILD_SIZE=$(du -sh dist | cut -f1)
          FILE_COUNT=$(find dist -type f | wc -l)
          echo "‚úÖ Build completed (${BUILD_SIZE}, ${FILE_COUNT} files)"

      # 8. Sync to S3
      - name: Deploy to S3
        run: |
          cd app/frontend
          
          echo "Syncing to S3 bucket: ${{ steps.env.outputs.s3_bucket }}"
          
          # Sync all files except index.html with long cache
          aws s3 sync dist/ s3://${{ steps.env.outputs.s3_bucket }}/ \
            --delete \
            --cache-control "public,max-age=31536000,immutable" \
            --exclude "index.html" \
            --region ${{ secrets.AWS_REGION }}
          
          # Upload index.html separately with no cache
          aws s3 cp dist/index.html s3://${{ steps.env.outputs.s3_bucket }}/index.html \
            --cache-control "no-cache,no-store,must-revalidate" \
            --region ${{ secrets.AWS_REGION }}
          
          echo "‚úÖ Frontend deployed to S3"

      # 9. Verify Deployment
      - name: Verify S3 deployment
        run: |
          echo "Verifying S3 deployment..."
          
          # Check if index.html exists
          if aws s3 ls s3://${{ steps.env.outputs.s3_bucket }}/index.html --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
            echo "‚úÖ index.html verified"
          else
            echo "‚ùå index.html not found in S3"
            exit 1
          fi
          
          # Count files
          FILE_COUNT=$(aws s3 ls s3://${{ steps.env.outputs.s3_bucket }}/ --recursive --region ${{ secrets.AWS_REGION }} | wc -l)
          echo "‚úÖ Total files in S3: ${FILE_COUNT}"

      # 10. Invalidate CloudFront Cache
      - name: Invalidate CloudFront cache
        if: steps.cloudfront.outputs.distribution_id != ''
        run: |
          DISTRIBUTION_ID="${{ steps.cloudfront.outputs.distribution_id }}"
          
          echo "Invalidating CloudFront cache for distribution: ${DISTRIBUTION_ID}"
          
          # Create invalidation for all files
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "${DISTRIBUTION_ID}" \
            --paths "/*" \
            --query "Invalidation.Id" \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          echo "‚úÖ CloudFront invalidation created: ${INVALIDATION_ID}"
          echo ""
          echo "Note: Invalidation typically takes 1-2 minutes to complete globally."

      # 11. Show Frontend Deployment Info
      - name: Show frontend deployment information
        run: |
          echo ""
          echo "================================================"
          echo "üé® Frontend Deployment Successful!"
          echo "================================================"
          echo ""
          echo "S3 Bucket: ${{ steps.env.outputs.s3_bucket }}"
          echo "Environment: ${{ steps.env.outputs.environment }}"
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo ""
          echo "Access URLs:"
          if [[ -n "${{ steps.cloudfront.outputs.cloudfront_url }}" ]]; then
            echo "  üåê CloudFront (Primary): ${{ steps.cloudfront.outputs.cloudfront_url }}"
          fi
          echo "  üì¶ S3 Website: http://${{ steps.env.outputs.s3_bucket }}.s3-website-${{ secrets.AWS_REGION }}.amazonaws.com"
          echo ""
          if [[ -n "${{ steps.cloudfront.outputs.distribution_id }}" ]]; then
            echo "CloudFront Distribution ID: ${{ steps.cloudfront.outputs.distribution_id }}"
            echo ""
          fi
          echo "Deployed by: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          echo ""

  # Job 4: Terraform apply
  terraform-apply:
    name: Apply Terraform Changes
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.infra == 'true' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_terraform == 'true')
    runs-on: ubuntu-latest
    
    steps:
      # 1. Checkout
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      # 3. Configure AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 4. Determine Environment
      - name: Determine deployment environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="dev"
          else
            ENV="dev"
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to environment: ${ENV}"

      # 5. Terraform Format Check
      - name: Terraform Format Check
        run: |
          cd infra/terraform
          
          if ! terraform fmt -check -recursive; then
            echo "‚ö†Ô∏è  WARNING: Terraform files not formatted"
            echo "Run: terraform fmt -recursive"
          fi

      # 6. Terraform Init
      - name: Terraform Init
        run: |
          cd infra/terraform
          
          echo "================================================"
          echo "üîß Terraform Backend Initialization"
          echo "================================================"
          echo ""
          
          echo "Backend configuration (backend.tf):"
          echo "-----------------------------------"
          cat backend.tf
          echo ""
          
          echo "Running terraform init -reconfigure..."
          terraform init -input=false -reconfigure
          
          echo ""
          echo "‚úÖ Terraform initialized"
          echo ""
          
          echo "================================================"
          echo "üîç Verifying Remote State Connection"
          echo "================================================"
          echo ""
          
          if [ -f terraform.tfstate ]; then
            echo "‚ö†Ô∏è WARNING: Local terraform.tfstate found!"
            echo "This suggests backend is not configured correctly."
            ls -lh terraform.tfstate
            echo ""
          else
            echo "‚úÖ No local state file (correctly using remote backend)"
          fi
          
          echo ""
          echo "Resources in remote state:"
          echo "-----------------------------------"
          
          RESOURCE_COUNT=$(terraform state list 2>&1 | grep -v "^$" | wc -l)
          echo "  Total count: ${RESOURCE_COUNT}"
          
          if [ ${RESOURCE_COUNT} -eq 0 ]; then
            echo ""
            echo "‚ùå ERROR: State is EMPTY!"
            echo ""
            echo "Expected ~101 resources based on S3 state file."
            echo "This means Terraform is NOT reading from remote backend."
            echo ""
            echo "Debugging information:"
            echo "-----------------------------------"
            echo "  S3 Bucket: mira-terraform-state-dev"
            echo "  S3 Key: terraform.tfstate"
            echo "  Region: us-east-1"
            echo "  DynamoDB Lock Table: mira-terraform-locks"
            echo ""
            
            echo "Verifying S3 state file exists:"
            aws s3 ls s3://mira-terraform-state-dev/terraform.tfstate --human-readable
            
            echo ""
            echo "Attempting to read state metadata from S3:"
            aws s3api head-object \
              --bucket mira-terraform-state-dev \
              --key terraform.tfstate \
              --query '{Size:ContentLength,LastModified:LastModified}' || echo "Failed to read S3 object"
            
            echo ""
            echo "‚ùå ABORTING: Cannot proceed with empty state"
            exit 1
          else
            echo ""
            echo "‚úÖ State loaded successfully from S3!"
            echo ""
            echo "Sample resources (first 10):"
            terraform state list | head -10
            echo ""
            echo "Expected behavior: Plan should only show actual changes."
          fi
          
          echo ""
          echo "================================================"

      # 7. Terraform Validate
      - name: Terraform Validate
        run: |
          cd infra/terraform
          terraform validate
          echo "‚úÖ Terraform configuration is valid"

      # 8. Terraform Plan
      - name: Terraform Plan
        id: plan
        run: |
          cd infra/terraform
          
          echo "Running Terraform plan..."
          
          terraform plan -input=false -out=tfplan -detailed-exitcode > /tmp/plan_output.txt 2>&1 || true

          cat /tmp/plan_output.txt
    
          echo ""
          echo "================================================"
          echo "üîç Analyzing Plan Output"
          echo "================================================"
          echo ""

          if grep -q "No changes" /tmp/plan_output.txt; then
            echo "plan_has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No infrastructure changes needed"
            
          elif grep -q "Plan: 0 to add, 0 to change, 0 to destroy" /tmp/plan_output.txt; then
            echo "plan_has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No infrastructure changes needed"
            
          elif grep -q "Error:" /tmp/plan_output.txt; then
            echo "‚ùå Terraform plan encountered errors"
            exit 1
            
          else
            PLAN_LINE=$(grep "Plan:" /tmp/plan_output.txt | tail -1)
            echo "Detected changes: ${PLAN_LINE}"
            
            echo "plan_has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected - will apply"
          fi

      # 9. Show Plan Summary
      - name: Show Terraform Plan
        if: steps.plan.outputs.plan_has_changes == 'true'
        run: |
          cd infra/terraform
          
          echo ""
          echo "================================================"
          echo "üìã Terraform Plan Summary"
          echo "================================================"
          echo ""
          
          terraform show tfplan
          
          echo ""
          echo "================================================"

      # 10. Terraform Apply
      - name: Terraform Apply
        if: steps.plan.outputs.plan_has_changes == 'true'
        run: |
          cd infra/terraform
          
          echo "Applying Terraform changes..."
          terraform apply -input=false tfplan
          
          echo "‚úÖ Terraform apply completed successfully"

      # 11. Show Terraform Outputs
      - name: Show Terraform Outputs
        if: steps.plan.outputs.plan_has_changes == 'true'
        run: |
          cd infra/terraform
          
          echo ""
          echo "================================================"
          echo "üì§ Terraform Outputs"
          echo "================================================"
          echo ""
          
          terraform output

      # 12. Show Terraform Deployment Info
      - name: Show Terraform deployment information
        run: |
          echo ""
          echo "================================================"
          echo "üèóÔ∏è Terraform Deployment Complete!"
          echo "================================================"
          echo ""
          echo "Environment: ${{ steps.env.outputs.environment }}"
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo "Changes Applied: ${{ steps.plan.outputs.plan_has_changes || 'false' }}"
          echo ""
          echo "Deployed by: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          echo ""

  # Job 5: deployment summary
  deployment-summary:
    name: Deployment Summary
    needs: [detect-changes, deploy-lambda, deploy-frontend, terraform-apply]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Generate complete deployment summary
        run: |
          echo ""
          echo "========================================"
          echo "üìä Complete Deployment Summary"
          echo "========================================"
          echo ""
          echo "Trigger Information:"
          echo "  Event: ${{ github.event_name }}"
          echo "  Branch: ${{ github.ref_name }}"
          echo "  Commit: ${{ github.sha }}"
          echo "  Author: ${{ github.actor }}"
          echo ""
          echo "File Changes Detected:"
          echo "  Backend: ${{ needs.detect-changes.outputs.backend }}"
          echo "  Frontend: ${{ needs.detect-changes.outputs.frontend }}"
          echo "  Infrastructure: ${{ needs.detect-changes.outputs.infra }}"
          echo ""
          echo "Deployment Results:"
          echo "  Lambda: ${{ needs.deploy-lambda.result }}"
          echo "  Frontend: ${{ needs.deploy-frontend.result }}"
          echo "  Terraform: ${{ needs.terraform-apply.result }}"
          echo ""
          
          # Determine overall status
          LAMBDA_STATUS="${{ needs.deploy-lambda.result }}"
          FRONTEND_STATUS="${{ needs.deploy-frontend.result }}"
          TERRAFORM_STATUS="${{ needs.terraform-apply.result }}"
          
          if [[ "$LAMBDA_STATUS" == "failure" ]] || \
             [[ "$FRONTEND_STATUS" == "failure" ]] || \
             [[ "$TERRAFORM_STATUS" == "failure" ]]; then
            echo "‚ùå Overall Status: FAILED"
            echo ""
            echo "Check the failed job(s) above for error details"
            exit 1
          elif [[ "$LAMBDA_STATUS" == "skipped" ]] && \
               [[ "$FRONTEND_STATUS" == "skipped" ]] && \
               [[ "$TERRAFORM_STATUS" == "skipped" ]]; then
            echo "‚ÑπÔ∏è  Overall Status: NO CHANGES DETECTED"
            echo ""
            echo "No deployment was necessary - all components are up to date"
          else
            echo "‚úÖ Overall Status: SUCCESS"
            echo ""
            echo "=========================================="
            echo "üéâ All Deployments Completed Successfully!"
            echo "=========================================="
            echo ""
            
            # Show what was deployed
            if [[ "$LAMBDA_STATUS" == "success" ]]; then
              echo "‚úÖ Lambda deployed"
            fi
            if [[ "$FRONTEND_STATUS" == "success" ]]; then
              echo "‚úÖ Frontend deployed"
            fi
            if [[ "$TERRAFORM_STATUS" == "success" ]]; then
              echo "‚úÖ Infrastructure updated"
            fi
            
            echo ""
            echo "Deployment completed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          fi